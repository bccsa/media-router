import { WHEPSession, WhepServerSettings } from "../whep-server-gstreamer";
import GObject from "@girs/node-gobject-2.0";
import {
    gstCreateAnswer,
    gstSetLocalDescription,
    gstSetRemoteDescription,
    enableRtpRed,
    startBin,
} from "./";

/**
 * Filters an SDP string to create an audio-only, receive-only stream
 * We had some issues with the SDP generated by MediaMtx, that it made webrtcbin freeze up, that is why we are
 * regenerating the SDP here, and only keeping the origin, ice-ufrag, ice-pwd and fingerprint lines.
 * Opus and RED are supported almost everywhere, so we dont see this as being a problem.
 * @param sdp - The input SDP string
 * @returns Filtered SDP string containing only audio receive-only parameters
 */
export function filterSdp(sdp: string): string {
    const lines = sdp
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line.length > 0);
    const filteredLines: string[] = [];

    // Extract dynamic values from input SDP
    let originLine = "";
    let iceUfragLine = "";
    let icePwdLine = "";
    let fingerprintLine = "";

    for (const line of lines) {
        if (line.startsWith("o=")) {
            originLine = line;
        } else if (line.startsWith("a=ice-ufrag:")) {
            iceUfragLine = line;
        } else if (line.startsWith("a=ice-pwd:")) {
            icePwdLine = line;
        } else if (line.startsWith("a=fingerprint:")) {
            fingerprintLine = line;
        }
    }

    // Add required session-level attributes
    filteredLines.push("v=0");
    if (originLine) {
        filteredLines.push(originLine);
    }
    filteredLines.push("s=-");
    filteredLines.push("t=0 0");
    filteredLines.push("a=group:BUNDLE 0");
    filteredLines.push("a=extmap-allow-mixed");
    filteredLines.push("a=msid-semantic: WMS");

    // Add audio-only media description (receive-only)
    filteredLines.push("m=audio 9 UDP/TLS/RTP/SAVPF 111 63 9 0 8 13 110 126");
    filteredLines.push("c=IN IP4 0.0.0.0");
    filteredLines.push("a=rtcp:9 IN IP4 0.0.0.0");

    // Add ICE parameters
    if (iceUfragLine) {
        filteredLines.push(iceUfragLine);
    }
    if (icePwdLine) {
        filteredLines.push(icePwdLine);
    }
    filteredLines.push("a=ice-options:trickle");

    // Add security parameters
    if (fingerprintLine) {
        filteredLines.push(fingerprintLine);
    }
    filteredLines.push("a=setup:actpass");

    // Add media-level attributes
    filteredLines.push("a=mid:0");
    filteredLines.push(
        "a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level"
    );
    filteredLines.push(
        "a=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"
    );
    filteredLines.push(
        "a=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
    );
    filteredLines.push("a=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid");

    // Set direction to receive-only
    filteredLines.push("a=recvonly");

    // Add RTP/RTCP attributes
    filteredLines.push("a=rtcp-mux");
    filteredLines.push("a=rtcp-rsize");

    // Add audio codec parameters (Opus and RED)
    filteredLines.push("a=rtpmap:111 opus/48000/2");
    filteredLines.push("a=rtcp-fb:111 transport-cc");
    filteredLines.push("a=fmtp:111 minptime=10;useinbandfec=1");
    filteredLines.push("a=rtpmap:63 red/48000/2");
    filteredLines.push("a=fmtp:63 111/111");

    return filteredLines.join("\n") + "\n";
}

/**
 * Modifies the SDP to include ICE candidates.
 * @param sdp - The input SDP string
 * @param candidates - The ICE candidates to add
 * @returns The modified SDP string with added ICE candidates
 */
export function sdpMudgeIceCandidates(
    sdp: string,
    candidates: string[]
): string {
    // Parse the SDP to find the m= line
    const lines = sdp.split("\n");
    const mLineIndex = lines.findIndex((line) => line.startsWith("m="));

    if (mLineIndex === -1) {
        console.error("‚ùå No media line found in SDP");
        return sdp;
    }

    // Insert each candidate after the m= line
    candidates.forEach((candidate) => {
        lines.splice(mLineIndex + 1, 0, `a=${candidate}`);
    });

    return lines.join("\n");
}

/**
 * Modifies the SDP to include audio RED encoding. (This function is not used, and can delete at a later time)
 * @param sdp - The input SDP string
 * @returns The modified SDP string with audio RED encoding
 */
export function sdpMudgeAudioRedEnc(sdp: string): string {
    // Parse the SDP to find the m= line
    const lines = sdp.split("\n");
    const mLineIndex = lines.findIndex((line) => line.startsWith("m="));
    if (mLineIndex === -1) {
        console.error("‚ùå No media line found in SDP");
        return sdp;
    }

    // Add the RED encoder pt in the m= line
    const mLine = lines[mLineIndex];
    lines[mLineIndex] = mLine.replace("111 63", "63 111");

    return lines.join("\n");
}

/**
 * Creates an SDP answer for a WHEP session.
 * This function sets the remote description, creates an answer, and adds ICE candidates.
 * It also enables RTP RED encoding if specified in the settings.
 * @param session - The WHEP session to create the answer for
 * @param settings - The WHEP server settings
 * @returns The generated SDP answer or null if failed
 */
export function createSdpAnswer(
    session: WHEPSession,
    settings: WhepServerSettings
): Promise<string | null> {
    console.log("ü§ù Creating WebRTC sdp answer...");

    return new Promise(async (resolve) => {
        const sdpOffer = (session as any).sdpOffer;
        if (!sdpOffer) {
            console.error("‚ùå No SDP offer stored");
            return null;
        }

        // gather all ICE candidates that will be mudged into the SDP
        const iceCandidates: string[] = [];
        session.whepBin.webrtc.connect(
            "on-ice-candidate",
            (num, candidate: string) => {
                iceCandidates.push(candidate);
            }
        );

        /**
         * Update the ICE gathering state to wait for it to be complete
         * This is necessary to ensure that all ICE candidates are gathered before proceeding.
         * The state is 2 when gathering is complete, and we will wait for it to be set.
         * If it takes too long, we will timeout after 3 seconds.
         */
        let iceGatheringState: number = 0;
        session.whepBin.webrtc.connect("notify::ice-gathering-state", () => {
            iceGatheringState = (
                session.whepBin.webrtc.getProperty(
                    "ice-gathering-state"
                ) as GObject.Value
            ).getBoxed();
        });

        await gstSetRemoteDescription(session.whepBin.webrtc, sdpOffer);
        const answer = await gstCreateAnswer(session.whepBin.webrtc);
        if (!answer) {
            console.error("‚ùå Failed to create answer");
            resolve(null);
        }

        gstSetLocalDescription(session.whepBin.webrtc, answer);

        /**
         * This is the fallback to wait for the ICE gathering state to be complete.
         */
        await new Promise<void>((resolve) => {
            const _startTime = Date.now();
            const _timeout = 3000; // 3 seconds timeout
            const checkCandidates = () => {
                if (
                    iceGatheringState == 2 ||
                    Date.now() - _startTime > _timeout
                ) {
                    resolve();
                } else {
                    setTimeout(checkCandidates, 100);
                }
            };
            checkCandidates();
        });

        enableRtpRed(session.whepBin, settings.rtpRed, settings.rtpRedDistance);

        // add the ICE candidates to the SDP
        const mudgedSdpWithCandidates = sdpMudgeIceCandidates(
            answer.sdp.asText(),
            iceCandidates
        );

        resolve(mudgedSdpWithCandidates);
    });
}

/**
 * Generate sdp awnser
 * @param session - The WHEP session to generate the answer for
 * @param settings - The WHEP server settings
 * @returns
 */
export async function generateAnswer(
    session: WHEPSession,
    settings: WhepServerSettings
): Promise<string | null> {
    try {
        console.log(`üìù Generating SDP answer for session ${session.id}`);

        // Use a promise-based approach since the GStreamer bindings have limitations
        return new Promise<string>(async (resolve, reject) => {
            // Start the pipeline first
            console.log(`üöÄ Starting webrtcBin for session: ${session.id}`);
            const ret = startBin(session.whepBin);
            if (!ret) {
                reject(new Error("Failed to start webrtc element"));
                return;
            }

            const sdpAnswer = await createSdpAnswer(session, settings);

            if (!sdpAnswer) {
                console.error("‚ùå Failed to create SDP answer");
                reject(new Error("Failed to create SDP answer"));
                return;
            }

            resolve(sdpAnswer);
        });
    } catch (error) {
        console.error("‚ùå Error generating answer:", error);
        return null;
    }
}
